---
title: End-to-end Type Safety from Nitro to Nuxt
description: Let's explore how Nuxt 3 provides end-to-end type safety with an example followed by tips and best practices.
navigation: false
image: /assets/blog/going-full-static.png
authors:
  - name: Krutie Patel
    avatarUrl: https://avatars.githubusercontent.com/u/19180970?v=4
    link: https://twitter.com/KrutiePatel
date: 2024-03-01T00:00:00.000Z
category: Article
---

The order of compile-time, build-time, and runtime in the development of a Nuxt 3 application is sequential and reflects the stages from code development to execution. Hereâ€™s how they unfold:

1. **Compile-time:** This is the first stage in the process. During compile-time, your source code, which may include TypeScript or Vue Single File Components (SFCs), is translated into executable JavaScript code. For TypeScript, this involves type checking and compiling TypeScript into JavaScript. For Vue components, the Vue SFC compiler processes the template, script, and style sections of `.vue` files into a format that can be understood by browsers.

2. **Build-time:** Once the compile-time phase is successfully completed, the project moves into the build-time phase. During build-time, Nuxt 3 takes the compiled code and performs several optimisation steps such as minification, tree shaking, and code splitting.

3. **Runtime:** The final stage is run-time. During run-time, the application executes in either server-side (for SSR Nuxt applications) or client-side environment (for SSG Nuxt applications). 

Compile-time is when the TypeScript is converted into JavaScript, so all compile-time TypeScript errors need to be fixed before moving on to the next stage so that there are no surprises at runtime.

With the release of version 3, Nuxt offers robust support for TypeScript and type checking out of the box. This article takes a look at how Nuxt 3 provides end-to-end type safety with an example followed by tips and best practices.

### Nuxt 3 and TypeScript

While Vue 3 Composition API works seamlessly with TypeScript that allows precise typing of component props, event emitters, reactive variables and computed properties, Nuxt 3 on the other hand, has also native support for TypeScript that eliminates the need for extensive configuration and additional plugins to get started with TypeScript in your Nuxt project.

**Typed Configuration:** Nuxt 3 allows you to write your `nuxt.config.ts` file in TypeScript, offering auto-completion and type checking for Nuxt configuration options. 

Same is true for your `app.config.ts` as well. Nuxt automatically generates a TypeScript interface from the provided app config. In some cases, if you require custom types, you can type `app.config` yourself as well. 

```ts []
export default defineAppConfig({
  myLayer: {
    name: 'Hello from Nuxt layer',
    theme: {
      primary: { /* ... */},
      secondary: { /* ... */}
    }
  }
})

declare module '@nuxt/schema' {
  interface AppConfigInput {
    myLayer?: {
      name?: string,
      theme?: {
        primary?: ColorPalette,
        secondary?: ColorPalette
      }
    }
  }
}
```



::read-more
---
to: https://github.com/Krutie/nuxt-layers-playground/blob/main/packages/nuxt-ui-layer/app.config.ts
color: green
target: _blank
---
See the full working example of how you can type-safe the shape of [custom app.config here.](https://github.com/Krutie/nuxt-layers-playground/blob/main/packages/nuxt-ui-layer/app.config.ts)

::

**Modules and Plugins Typing:** Support for TypeScript in modules and plugins enables you to extend your Nuxt applications while maintaining type safety.

When you run `nuxi dev` or `nuxi build`, Nuxt generates `.nuxt/nuxt.d.ts`, `.nuxt/tsconfig.json` and `.nuxt/tsconfig.server.json`.

 `.nuxt/nuxt.d.ts` includes types generated by Nuxt for modules, plugins, components and more, while `.nuxt/tsconfig.json` includes default `compilerOptions` for TypeScript configuration that you can override in `~/tsconfig.json` if required.


**Typed API Routes:** With Nitro, the new server engine for Nuxt 3, you can define API routes using TypeScript, ensuring that request handlers are type-safe.

When you create a new Nuxt project, default `../.nuxt/tsconfig.server.json` is already added for you in the `~/server` directory.

```ts [~/server/tsconfig.json]
{
  "extends": "../.nuxt/tsconfig.server.json"
}
```

In full-stack Nuxt applications, Types can be shared between the frontend and backend parts of your application, providing a consistent development experience and reducing errors caused by mismatches in data structures.

### Practical Example: A Typed Nitro to Nuxt Application 

Nitro allows defining server-side API routes directly within the Nuxt 3 project. By typing request handlers and the data they return, you can ensure that the server-side logic is consistent with the client-side expectations.

Let's take Daniel Roe's [page-speed.dev](https://github.com/danielroe/page-speed.dev) project as an example to understand the concept of sharing types between backend and frontend - from Nitro to Nuxt.

This project uses [PageSpeed Insights API](https://developers.google.com/speed/docs/insights/v5/get-started) to fetch the `performance`, `seo`, `accessibility` and `best-practices` scores for the domain name entered by the user. 

In the `~/server/api` directory, you have two endpoints that extracts the value of the `domain` from route parameter, calls an API within `defineCachedEventHandler` and returns a response.

```ts
// ~/server/api/run/[domain].get.ts

export default defineCachedEventHandler(async (event) => {
  /* ... */
  const results = await $fetch<PagespeedInsightsResult>(`/runPagespeed?url=${encodeURIComponent(`https://${domain}`)}&category=ACCESSIBILITY&category=BEST_PRACTICES&category=PERFORMANCE&category=SEO&strategy=mobile&key=${token}`, {
    baseURL: 'https://www.googleapis.com/pagespeedonline/v5',
  })
  /* ... */
}, { /* ... */ })
```

`PagespeedInsightsResult` ðŸ‘† is the [format of the data](https://developers.google.com/speed/docs/insights/v5/reference/pagespeedapi/runpagespeed#response) you get back from the PageSpeed API. But, when you return this data ðŸ‘‡ from `defineCachedEventHandler`, you don't need to specify its type because it is automatically detected when this API endpoint is consumed in the frontend.

```ts
// ~/server/api/run/[domain].get.ts

export default defineCachedEventHandler(async (event) => {
  /* ... */
  return {
    performance: results.lighthouseResult.categories.performance.score * 100,
    seo: results.lighthouseResult.categories.seo.score * 100,
    accessibility: results.lighthouseResult.categories.accessibility.score * 100,
    bestPractices: results.lighthouseResult.categories['best-practices'].score * 100,
    timestamp: Date.now(),
  }
}, { /* ... */ })
```

 In the frontend, specifically within the `~/app.vue` component, an internal API endpoint is accessed using the combination of `useAsyncData` and `$fetch`. ðŸ‘‡ The `useAsyncData` function is utilised to handle asynchronous data fetching, allowing the component to wait for data to be loaded before rendering. Meanwhile, `$fetch` is used to actually make the request to the internal API endpoint.

```ts [~/app.vue]
<script lang="ts" setup>
  const { data: lighthouse } = await useAsyncData(() => $fetch(`/api/run/${domain.value}`), { /* ... */ })
</script>
```

The integration of TypeScript provides you with real-time feedback in your IDEs, including intelligent code completion and inline error highlighting. As a result, when you examine `lighthouse` data ðŸ‘‡ by hovering over it, you'll notice that every key within this object is accurately typed. 

![alt text](/assets/blog/end-to-end-ts-safety-01.png "Title"){.border.border-gray-200.dark:border-gray-700.rounded-lg.w-[40%]}

Furthermore, as you prepare to input the API endpoint within the `$fetch` function in the frontend, Nuxt allows you to view a list of all the API endpoints originating from the Nitro `~/server` directory. When you access `$fetch` and begin to type in the endpoint's path ðŸ‘‡ , this integration facilitates an easier and more efficient way to ensure you are calling the correct endpoint.

![alt text](/assets/blog/end-to-end-ts-safety-02.png "Title"){.border.border-gray-200.dark:border-gray-700.rounded-lg.w-[700px]}

This is how TypeScript in Nuxt enhances the development experience by streamlining the process of connecting your frontend components to the backend logic, ensuring that data flow and API interactions are seamless and error-free.

Similar setup and TypeScript behaviour can be observed in `~/server/api/crux/[domain].get.ts` where the project uses [CrUX - Chrome User Experience API](https://developer.chrome.com/docs/crux/guides/crux-api) to fetch the UX report for a given domain.

### How does Nuxt 3 auto-generate schemas and types?

[`Untyped`](https://unjs.io/packages/untyped) package is a crucial part of the [Unjs](https://unjs.io/) ecosystem. Nuxt uses the `untyped` package under the hood for several important tasks related to application configuration and documentation.

One of the key functionalities of the `untyped` package within Nuxt is its ability to automatically generate schema and types. This means that from a given configuration object, the package can produce a detailed schema that describes the structure and expected data types of the configuration.

The `untyped` package goes beyond just generating schemas and types; it is also capable of generating markdown documentation. This feature is particularly beneficial for creating clear and concise documentation automatically from the configuration object.

::read-more
---
to: https://untyped.unjs.io/
color: green
target: _blank
---
Explore this impressive [tool](https://untyped.unjs.io/) which offers a hands-on demonstration of how `untyped` transforms the structure of any reference object or function signatures into schema and types.
::

### Further Type Check Support

While TypeScript is primarily a compile-time tool, Nuxt 3's support ensures that types are checked during development. You can set `typeCheck` to  `true` in your Nuxt config along with the use of tools like `vue-tsc` for additional type checking and validation.

```ts [~/nuxt.config.ts]
export default defineNuxtConfig({
  typescript: {
    typeCheck: true
  }
})
```

Now, when you run `npx nuxi typecheck` in your terminal, Nuxt will perform type-checking at development time.

### Tips and Best Practices

ðŸ‘‰ **Use Strict Mode:** Enable strict mode in your tsconfig.json. It forces you to write more type-safe code by not allowing implicit any types, ensuring that you explicitly define types for all parts of your application.

```ts [~/nuxt.config.ts]
export default defineNuxtConfig({
  typescript: {
    strict: true
  }
})
```

ðŸ‘‰ **Embrace the Composition API:** The Composition API in Vue 3 is designed with TypeScript in mind. Utilise it to structure your components and logic, taking full advantage of TypeScript's type inference and auto-completion features to write more reliable Vue code.

ðŸ‘‰ **Access Types from Nuxt Layers**: When using Nuxt Layers, leverage the `localLayerAliases` option in the Nuxt configuration of your primary Nuxt application to use the automatically generated `tsconfig.json` types across your Layers and the primary application. Read more about this [configuration here.](https://github.com/Krutie/nuxt-layers-playground/issues/2)

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  experimental: {
    localLayerAliases: true
  }
})
```

ðŸ‘‰ **Define Clear Interfaces and Types:** Create interfaces and types for your data models, API responses, event emitters, reactive variables, and component props. This practice makes your code more readable and maintainable, and it helps prevent bugs related to incorrect data types.

ðŸ‘‰ **Regularly Review and Refactor:** Apart from what Nuxt already does for you, regularly review and refactor your type definitions and usage as your Nuxt application evolves. Keeping your types up-to-date with the actual structure of your data and application logic is crucial for maintaining type safety.

By following these practices, you can build robust, error-resistant applications with Nuxt 3 and Nitro, ensuring a seamless development experience from start to finish.

Thank you for reading this far! We hope you enjoy the type-safe Nuxt. Please let us know if you have any feedback or issues.

**Happy Nuxting âœ¨**
